/**
 * PDFExporter class - Exports data to PDF format
 */

import * as fs from 'fs'
import * as path from 'path'
import { BaseExporter, ExportOptions } from './BaseExporter'

// We'll use PDFKit for PDF generation
// First, let's add the dependency to package.json
// npm install pdfkit @types/pdfkit

export class PDFExporter extends BaseExporter {
    /**
     * Export data to PDF format
     * @param data The data to export
     * @param outputPath Path to save the PDF file
     * @param options Export options
     */
    async export(data: any[], outputPath: string, options?: ExportOptions): Promise<boolean> {
        try {
            // Process data before export
            const processedData = this.processData(data, options)
            
            if (processedData.length === 0) {
                this.logger.warn('No data to export to PDF')
                return false
            }

            // Ensure directory exists
            const dir = path.dirname(outputPath)
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true })
            }
            
            // Dynamically import PDFKit to avoid requiring it as a dependency
            // if the user doesn't use PDF export
            try {
                const PDFDocument = require('pdfkit')
                
                // Create a document
                const doc = new PDFDocument({ margin: 50 })
                
                // Pipe output to file
                const stream = fs.createWriteStream(outputPath)
                doc.pipe(stream)
                
                // Add title
                doc.fontSize(20).text('Exported Data', { align: 'center' })
                doc.moveDown()
                
                // Add metadata
                doc.fontSize(10)
                   .text(`Export Date: ${new Date().toLocaleString()}`)
                   .text(`Record Count: ${processedData.length}`)
                   .text(`Generated by: Flowise Export Utility`)
                
                doc.moveDown()
                
                // Get headers from the first item
                const headers = Object.keys(processedData[0])
                
                // Add table headers
                this.addTableHeaders(doc, headers)
                
                // Add table rows
                this.addTableRows(doc, processedData, headers)
                
                // Finalize PDF file
                doc.end()
                
                // Wait for the stream to finish
                await new Promise<void>((resolve, reject) => {
                    stream.on('finish', () => {
                        this.logger.info(`Successfully exported ${processedData.length} records to PDF: ${outputPath}`)
                        resolve()
                    })
                    stream.on('error', reject)
                })
                
                return true
            } catch (error) {
                this.logger.error(`PDFKit dependency not found. Please install it using: npm install pdfkit`)
                this.logger.error(`Error details: ${error instanceof Error ? error.message : String(error)}`)
                return false
            }
        } catch (error) {
            this.logger.error(`Error exporting to PDF: ${error instanceof Error ? error.message : String(error)}`)
            return false
        }
    }
    
    /**
     * Add table headers to the PDF document
     * @param doc PDF document
     * @param headers Table headers
     */
    private addTableHeaders(doc: any, headers: string[]): void {
        // Set up table header
        doc.fontSize(12).font('Helvetica-Bold')
        
        // Calculate column width
        const pageWidth = doc.page.width - 100 // Accounting for margins
        const colWidth = pageWidth / headers.length
        
        // Draw header cells
        let x = 50
        headers.forEach(header => {
            doc.text(this.formatHeader(header), x, doc.y, { width: colWidth, align: 'left' })
            x += colWidth
        })
        
        doc.moveDown()
        doc.font('Helvetica') // Reset to normal font
    }
    
    /**
     * Add table rows to the PDF document
     * @param doc PDF document
     * @param data Data rows
     * @param headers Table headers
     */
    private addTableRows(doc: any, data: any[], headers: string[]): void {
        // Calculate column width
        const pageWidth = doc.page.width - 100 // Accounting for margins
        const colWidth = pageWidth / headers.length
        
        // Draw rows
        data.forEach((row, rowIndex) => {
            // Add a page break every 30 rows
            if (rowIndex > 0 && rowIndex % 30 === 0) {
                doc.addPage()
                this.addTableHeaders(doc, headers) // Add headers to new page
            }
            
            let x = 50
            let maxHeight = 0
            
            // First pass to determine row height
            headers.forEach(header => {
                const value = this.formatCellValue(row[header])
                const textHeight = doc.heightOfString(value, { width: colWidth })
                maxHeight = Math.max(maxHeight, textHeight)
            })
            
            // Second pass to draw cells
            const y = doc.y
            headers.forEach(header => {
                const value = this.formatCellValue(row[header])
                doc.text(value, x, y, { width: colWidth, height: maxHeight })
                x += colWidth
            })
            
            doc.moveDown()
            
            // Add a light gray line after each row
            if (rowIndex < data.length - 1) {
                doc.strokeColor('#CCCCCC')
                   .lineWidth(0.5)
                   .moveTo(50, doc.y)
                   .lineTo(doc.page.width - 50, doc.y)
                   .stroke()
                   .moveDown(0.5)
            }
        })
    }
    
    /**
     * Format header text for display
     * @param header Header text
     */
    private formatHeader(header: string): string {
        // Convert camelCase or snake_case to Title Case
        return header
            .replace(/([A-Z])/g, ' $1') // Insert space before capital letters
            .replace(/_/g, ' ') // Replace underscores with spaces
            .replace(/^\w/, c => c.toUpperCase()) // Capitalize first letter
            .trim()
    }
    
    /**
     * Format cell value for display
     * @param value Cell value
     */
    private formatCellValue(value: any): string {
        if (value === null || value === undefined) {
            return ''
        } else if (typeof value === 'object') {
            // Truncate long JSON strings
            const json = JSON.stringify(value)
            return json.length > 100 ? json.substring(0, 97) + '...' : json
        } else {
            return String(value)
        }
    }
}
